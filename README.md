# ContestOzonGolangSchool2020
Решение задач отбора на школу Go разработки Ozon

ТЗ лежит в корне в pdf

В итоге не решил последнюю задачу E на go.
Проблема в том, что есть ситуация, когда пишет ошибку WA и в логах пусто.
Пробовал разные подходы.

Получилось 11 вариантов, хотя первый слишком медленный, но он был нужен для тестов :)
1) asyncF - просто в goroutine запускаем перебор, выдает IL стабильно, что ожидаемо.
2) asyncF2 - расчет f по каждому входному каналу в отдельной goroutine, синхронизация через WaitGroup.
3) asyncChannels - по сути тоже самое, что и async2, но результаты вычислений пишутся в промежуточные каналы, которые читает и складывает еще одна goroutine
4) asyncFAndSum - одна goroutine на вычисление, другая на сложение, результаты из первой во вторую передаются через каналы
5) sync1WG - в goroutine вычисляем сумму и ждем через WaitGroup.
6) sync2WG - на каждую итерацию запускаем goroutine, которая вычисляет сумму и ожидает завершения предыдущей goroutine перед тем как писать в Out, чтобы соблюсти порядок.
7) sync4WG - тоже самое, что и sync2WG, только чтение из каналов и вычисление так же разнесено на разные goroutine и синхронизируется через WaitGroup, но судя из того что запись в каналы выполнена перед запуском первого теста толку нет, только лишние накладные расходы.
8) mapAndChan - для каждого входного канала goroutine читает значение и на каждую итерацию запускает еще одну goroutine для вычисления результата и сохранения в syncMap, где ключ - это номер итерации, а значение это результат выполнения f, так же после записи в syncMap, через канал посылается сигнал, что в syncMap есть что почитать. Еще одна goroutine читает syncMap по сигналу, и пишет в промежуточный канал. Последняя goroutine читает промежуточные каналы и складывает.
9) map2out - тоже что и mapAndChan, только goroutine читает сразу syncMap каждого канала и складывает сразу в out. Думаю, что чтение каналов в mapAndChan, эффективнее, чем опрос syncMap, особонно если вычисление f абсолютно разное время занимает, а порядок в Out сохранять нужно..
10) mapAndCache - аналогично mapAndChan, только расчеты f кэшируются и если есть одинаковые значения во входных каналах, то заметно прибавляет в скорости..
11) syncCounter - похоже на mapAndChan, только вместо отдельной goroutine syncMap читает та же goroutine, что и вычисляет f для конкретной итерации, а синхронизацию, для порядка в out обеспечивает счетчик, который через мьютекс считается. Просто попробовал ради интереса, а так тоже мьютекс думаю дороже, чем лишняя goroutine и передача через каналы.

Самые быстрые получились это map2out и sync2WG. Суть у них одна, это вычислять f для каждого значения асинхронно, но при этом запоминая порядок для выдачи суммы в out. Первая делает это через мьютекс, вторая через WaitGroup

По остальным задачам нет проблем, если не тупить, ничего особенного они не представляют, хотя я бы попробовал решить F на nodejs еще..
У меня они решены на C# 
